# Корреляция изображений: теория и разбор кода

Документ описывает простую теорию корреляции, взаимной корреляции (поиск фрагмента) и автокорреляции (поиск повторяющихся шаблонов), а также объясняет, как это реализовано в проекте и что показывают визуализации.

## Что делает программа

- Режим 4а (взаимная корреляция, NCC): находит заданный фрагмент внутри изображения. Интерфейс показывает исходник, выбранный фрагмент и «карту NCC». В найденном месте на исходнике рисуется прямоугольник.
- Режим 4б (автокорреляция, ACF): выявляет регулярные повторы в изображении. Интерфейс показывает исходник, «карту ACF» и список наиболее сильных смещений, соответствующих повторяющимся структурам.

Файл с основным кодом: `manual_correlation_app.py`.

## Минимальная теория простыми словами

### Корреляция
- Сравнение похожести двух «похожих по форме» вещей. Для изображений — сравниваются значения яркости пикселей.
- Идея: «если при сдвиге совпадает как можно больше деталей, то сходство высокое».

### Взаимная корреляция (поиск фрагмента)
- Берём небольшой «шаблон» (фрагмент) и «сканируем» им большое изображение, сравнивая совпадение в каждой позиции.
- Нормализованная взаимная корреляция (NCC) даёт оценку в диапазоне примерно от -1 до 1:
  - близко к 1 — фрагмент хорошо «ложится» на картинку в этой позиции;
  - около 0 — нет связи;
  - отрицательные — «антисовпадение» (редко нужно для поиска).
- Нормализация нужна, чтобы сравнение не зависело от общей яркости и контраста участка.

### Автокорреляция (поиск повторяющихся структур)
- Сравнивает изображение с самим собой, но со сдвигом. Для каждого сдвига (dx, dy) оценивается совпадение.
- Если в изображении есть периодичность/повторяющиеся элементы, то появятся «пики» корреляции при соответствующих сдвигах.
- В центре (dx=0, dy=0) всегда максимум — изображение полностью совпадает с собой. Его обычно показывают, но при анализе пиков игнорируют.

## Подробная теория алгоритмов

### Алгоритм NCC (нормализованная взаимная корреляция)

Задача: найти положение небольшого шаблона на большом изображении, сравнивая «структуру», а не абсолютную яркость.

Интуитивная идея:
- «Сканируем» шаблоном всё изображение и в каждой позиции измеряем похожесть. Чтобы освещённость не мешала, сравниваем не сырые значения, а значения без среднего и с учётом контраста.

Шаги алгоритма (понятно и без формул):
- Подготовка:
  - Перевести оба изображения в оттенки серого и числа с плавающей точкой.
  - У шаблона вычесть его среднюю яркость — так уберём общий фон (если шаблон в целом светлее или темнее, это больше не влияет на оценку).
- Для каждой позиции окна на большом изображении:
  - Взять окно того же размера, что шаблон.
  - Найти среднюю яркость окна и тоже «отцентрировать» окно (вычесть среднее), чтобы сравнение не зависело от локальной подсветки в этом месте.
  - Посчитать «совпадение по форме»: попиксельно перемножить центрированное окно и центрированный шаблон и сложить эти произведения. Чем больше сумма — тем больше деталей совпало.
  - Учесть контраст: сильные контрасты дают большие суммы сами по себе, поэтому делим на «силу» (контраст) окна и шаблона. Это делает оценку сравнимой везде.
  - Получаем число примерно от -1 до 1: ближе к 1 — хорошо совпало, около 0 — без связи, меньше 0 — «противоположные» контрасты.

Почему это работает:
- Вычитание среднего убирает влияние фоновой яркости.
- Деление на контраст делает метрику устойчивой к разным «резкостям» участков.
- Поэтому NCC — хороший универсальный способ искать фрагменты без «подгонки» порогов под конкретную яркость.

На что обратить внимание на практике:
- Почти однотонные шаблоны дают неопределённую оценку: контраста нет, считать нечего — такие шаблоны лучше не использовать.
- На границах изображения окно частично «вываливается» — обычно алгоритм просто не рассматривает такие позиции или берёт только валидные перекрытия.
- Если на изображении много одинаковых деталей, будет несколько пиков NCC. Тогда пригодится NMS (подавление близких максимумов) и порог по значению NCC.

Как объяснить на защите в двух фразах:
- «Я сканирую шаблон по изображению и в каждой позиции сравниваю не просто яркости, а отклонения от среднего, деля результат на контрасты. Это даёт число от -1 до 1, где 1 — идеальное попадание шаблона в это место».

### Алгоритм ACF (автокорреляция изображения)

Задача: найти, как хорошо изображение «похоже на себя» при разных сдвигах. Это выявляет регулярные повторы и периодичности.

Интуитивная идея:
- Берём копию изображения, двигаем её на вектор (dx, dy) и смотрим, насколько хорошо картинка совпадает сама с собой в зоне перекрытия. Повторяющиеся узоры дадут высокие значения при своих «правильных» сдвигах.

Шаги алгоритма без формул:
- Подготовка: вычесть среднюю яркость из изображения, чтобы убрать вклад «общего фона» (иначе всегда будет положительное совпадение «просто из-за фона»).
- Для каждого сдвига (dx, dy):
  - Сместить изображение на (dx, dy) и посчитать сходство на области, где обе версии перекрываются.
  - Нормировать на «силу» (контраст) и на размер перекрытия, чтобы значения были сопоставимы для разных сдвигов (на краях перекрытие меньше).
- В центре (0, 0) значение самое высокое — изображение идеально совпадает с собой. Его обычно приводят к 1.0 для удобства.

Как сделать быстро:
- Наивно перебирать все сдвиги долго. Есть стандартный трюк: посчитать автокорреляцию через быстрое преобразование Фурье (БПФ). Идея простая: мы преобразуем картинку в спектр, берём «мощность» (квадрат модуля), а затем делаем обратное преобразование — получаем все сдвиги за один проход. Это радикально ускоряет вычисления для больших изображений.

Как читать карту ACF:
- Яркая точка в центре — тривиальный максимум (совпадение без сдвига).
- Яркие точки вокруг центра — те сдвиги, при которых структура «совпадает сама с собой». Для регулярной сетки объектов пики образуют решётку; для периодических узоров — повторяющиеся гребни или точки в соответствующих направлениях.

Практические моменты:
- Нормировка на дисперсию и размер перекрытия делает карту честной: без неё края и центр могли бы быть «нечестно» ярче или темнее.
- В шумных изображениях карта будет «зернистой», но настоящие повторы обычно дают заметные локальные максимумы.
- Масштаб и поворот не компенсируются: если повторы есть, но под другим масштабом или углом, простая ACF их может не выявить.
- После построения карты имеет смысл исключить небольшую центральную область и применять NMS, чтобы выделить осмысленные пики.

Как объяснить на защите в двух фразах:
- «Я сравниваю картинку саму с собой при всех сдвигах. Для ускорения использую БПФ: считаю спектр мощности и обратным преобразованием получаю карту сдвигов. Яркие точки вне центра — это повторяющиеся смещения в изображении».

### БПФ и «спектр» простыми словами

Зачем вообще БПФ
- Наивно проверять все сдвиги долго: для каждого (dx, dy) пришлось бы пересчитывать большое количество попиксельных произведений.
- Есть «ярлык» из теории сигналов: автокорреляцию можно получить, если перейти в частотное представление (спектр), там сделать очень простую операцию, и вернуться назад. Это даёт все сдвиги сразу и намного быстрее.

Что такое «спектр» для изображения
- Изображение — это тоже сигнал, только двумерный: сетка чисел (яркостей). БПФ работает не только для звука; он работает для любых чисел на решётке — в том числе для картинок.
- «Спектр» показывает, сколько в изображении «медленных» и «быстрых» изменений:
  - Низкие частоты — плавные градиенты, большие пятна.
  - Высокие частоты — мелкая текстура, резкие границы.
- 2D‑БПФ — это тот же анализ частот, но по двум осям (по строкам и по столбцам).

Что такое «мощность» спектра
- Спектр в БПФ — комплексный (содержащий амплитуду и фазу). Нам для автокорреляции нужна «мощность» — сколько этой частоты «всего» присутствует, без учёта фазы.
- «Мощность» — это просто квадрат модуля комплексного числа (по сути, «амплитуда в квадрате»). Берём спектр, для каждого элемента считаем величину и возводим в квадрат.

При чём тут БПФ к автокорреляции
- Есть важный факт (необязательно запоминать название): автокорреляция сигнала = обратное БПФ от спектра мощности. То есть: посчитал БПФ, взял квадрат модуля, сделал обратное БПФ — получил автокорреляцию сразу для всех сдвигов.
- В коде это ровно то, что происходит в `autocorr_fft`: 
  1) центрируем изображение (вычитаем среднее, чтобы фон не мешал),
  2) считаем 2D‑БПФ,
  3) берём квадрат модуля (мощность),
  4) делаем обратное БПФ — получаем карту автокорреляции,
  5) сдвигаем центр в середину (`fftshift`) и корректно вырезаем линейную часть,
  6) нормируем на дисперсию и на размер перекрытия для честного сравнения разных сдвигов.

Почему это быстро
- Если считать «честно» для каждого сдвига — это очень много операций (почти квадратично по числу пикселей ещё и умноженное на число сдвигов).
- БПФ умеет переводить туда‑обратно за время порядка N log N (вместо N²). Мы один раз «заходим» в частоты, там делаем одну очень простую операцию (квадрат модуля), и возвращаемся. В итоге получаем автокорреляцию для всех сдвигов сразу.

Как объяснить в одной фразе
- «Картинка — это двумерный сигнал. Мы переводим её в частоты (БПФ), смотрим на энергию частот (мощность), и обратным преобразованием получаем карту «совпадения сдвигов» — так быстрее, чем проверять каждый сдвиг вручную».

## Как это реализовано в коде

Ниже кратко: где что считать в коде и как это работает.

### Подготовка изображений
- `prepare_image` масштабирует слишком большие картинки до приемлемого размера и сразу готовит серую матрицу яркости с плавающей точкой в [0..1].
  - Код: `manual_correlation_app.py:185`.
  - Важно: поле `scale` хранит коэффициент, чтобы потом правильно перевести координаты обратно к оригиналу.

### Взаимная корреляция (NCC)
- Основная функция: `CorrelationMath.normalized_cross_correlation(field, templ)` — `manual_correlation_app.py:45`.
- Что она делает:
  - Преобразует входы к float32, проверяет размеры.
  - Центрирует шаблон (вычитает среднее), чтобы сравнение не зависело от общей яркости фрагмента.
  - Быстро считает для каждого окна картинки его среднее и «энергию» с помощью интегральных сумм (ускоряет вычисления для всех позиций сразу).
  - Векторно извлекает все «окна» картинки через `sliding_window_view` и считает скалярные произведения с центрированным шаблоном для всех позиций за раз.
  - Делит на произведение норм (L2) шаблона и окна — это и есть нормализация (получаем значения примерно в [-1;1]).
  - Возвращает карту NCC: матрица, где каждое значение — качество совпадения шаблона, если его левый верхний угол поставить в эту позицию.
- На уровне интерфейса:
  - В `calculate_cross_correlation` (`manual_correlation_app.py:386`) карта NCC переводится в картинку для показа, берётся максимум, и на исходнике рисуется красный прямоугольник, соответствующий найденному месту (`_highlight_fragment`).
  - Также выполняется поиск нескольких лучших совпадений с подавлением близко расположенных максимумов (NMS):
    - Утилита `nms_peaks_from_map` — `manual_correlation_app.py:169`.
    - Обёртка `_build_match_candidates` — `manual_correlation_app.py:408`.
    - Список видимых кандидатов управляется `_update_match_list` и `_on_match_selected` — `manual_correlation_app.py:419`, `manual_correlation_app.py:435`.

Что показывается на «карте NCC»:
- Светлые области — выше NCC, значит туда хорошо «ложится» шаблон.
- Самая светлая точка обычно соответствует лучшему положению фрагмента.
- Если похожих мест много (повторяющийся паттерн), будет несколько светлых зон.

### Автокорреляция (ACF)
- Основная функция: `CorrelationMath.autocorr_fft(gray)` — `manual_correlation_app.py:101`.
- Что она делает:
  - Берёт серое изображение, вычитает среднее (центрирование), чтобы убрать вклад постоянной яркости.
  - Считает автокорреляцию через БПФ: берётся 2D FFT, затем обратное преобразование от спектра мощности (|F|^2). Это стандартный и быстрый способ.
  - Корректно центрирует результат (`fftshift`) и вырезает линейную часть нужного размера.
  - Нормирует результат на дисперсию изображения и на количество перекрывающихся пикселей при каждом сдвиге (это уменьшает «завал» к краям, где пересечение меньше).
  - Принудительно ставит центр равным 1.0 для стабильной интерпретации.
- Визуализация и пики:
  - `calculate_autocorrelation` (`manual_correlation_app.py:444`) показывает карту ACF и извлекает топ‑пики сдвигов `top_peaks_from_acf` — `manual_correlation_app.py:147`.
  - Из центра вокруг (0,0) небольшой квадрат исключается, чтобы не мешал главный максимум.
  - Пики упорядочены по силе; применяется простая NMS, чтобы пики не «слипались».
  - Список пиков фильтруется по относительной силе (отн. к максимуму) ползунком; обработка списка и выбор элемента — `manual_correlation_app.py:476`, `manual_correlation_app.py:504`.
- Что показывается на «карте ACF»:
  - Центр всегда самый яркий.
  - Яркие точки симметрично от центра — типичные сдвиги, при которых изображение «похоже само на себя». Это признаки периодичности/повторов.

### Наглядная демонстрация смещения (для ACF)
- При выборе пика (dx, dy) программа строит «призрачное» наложение исходника и его версии, сдвинутой на этот вектор смещения (`_highlight_autocorr_peak` — `manual_correlation_app.py:516`).
- Если видна явная «подсветка» совпадающих деталей в местах перекрытия — значит, найденный сдвиг реально отражает повтор.
- Координаты смещения пересчитываются с учётом масштаба, если ACF считалась по уменьшенной копии.

### Преобразование карт в изображения
- `CorrelationMath.correlation_to_image` — `manual_correlation_app.py:135`.
- Просто растягивает значения корреляции по мин–макс к диапазону 0..255 и переводит в RGB для корректного показа в Tkinter.

### Масштаб и координаты
- Изображения для расчётов могут уменьшаться до `MAX_CROSS_DIM`/`MAX_AUTO_DIM`, чтобы считать быстро.
- Поле `PreparedImage.scale` хранит отношение размеров «уменьшенного» к оригиналу.
- При рисовании результата на оригинале координаты и размеры домножаются на `1 / scale` (`_rect_from_corr_coords` — `manual_correlation_app.py:398`).

## Элементы интерфейса

- Кнопка «Загрузить изображение» — выбор файла.
- Переключатель режимов: «Взаимная корреляция» / «Автокорреляция».
- Взаимная корреляция:
  - «Случайный фрагмент» — вырезать случайный шаблон с оригинального изображения.
  - «Вычислить NCC» — построить карту совпадения и найти лучшее место.
  - Ползунок «Минимальный NCC» — отсекает слабые совпадения в списке кандидатов.
  - Список кандидатов — выбор интересующего совпадения подсветит его на исходнике.
- Автокорреляция:
  - «Вычислить ACF» — построить карту автокорреляции и найти пики смещений.
  - Ползунок «Минимальная относительная сила» — фильтрует пики относительно максимума.
  - Список пиков — при выборе строится наглядное наложение сдвига на исходнике.

## Как читать изображения функций

- Карта NCC (поиск фрагмента):
  - Один яркий максимум — шаблон найден однозначно.
  - Несколько максимумов — в изображении есть похожие места; используйте список кандидатов.
  - Если всё темно — порог слишком высок или фрагмент малоинформативен (однотонный участок).

- Карта ACF (повторы):
  - Яркие симметричные «узлы» вне центра — период повторения. Их координаты — вектора сдвига.
  - Если кроме центра почти ничего — выраженной периодичности/повторов нет.

## Ограничения и советы

- Однотонные и «плоские» фрагменты плохо ищутся (нормализация защищает от яркости, но не порождает текстуру).
- Масштаб и поворот шаблона не компенсируются: фрагмент должен быть такого же размера и ориентации.
- При сильном шуме или значительном пересжатии при масштабировании могут теряться мелкие детали — можно попробовать загрузить изображение меньших размеров или выбрать более текстурный фрагмент.

## Ключевые функции и места в коде

- Подготовка изображения: `manual_correlation_app.py:185` (`prepare_image`).
- Взаимная корреляция (NCC): `manual_correlation_app.py:45` (`CorrelationMath.normalized_cross_correlation`).
- Карта NCC → изображение: `manual_correlation_app.py:135` (`correlation_to_image`).
- Поиск пиков NCC (NMS): `manual_correlation_app.py:169` (`nms_peaks_from_map`).
- Построение списка совпадений: `manual_correlation_app.py:408` (`_build_match_candidates`).
- Автокорреляция (ACF, FFT): `manual_correlation_app.py:101` (`CorrelationMath.autocorr_fft`).
- Топ‑пики на ACF: `manual_correlation_app.py:147` (`top_peaks_from_acf`).
- Вычисление и показ ACF: `manual_correlation_app.py:444` (`calculate_autocorrelation`).
- Наглядное наложение по смещению: `manual_correlation_app.py:516` (`_highlight_autocorr_peak`).

## Коротко об алгоритмах без формул

- NCC: «окно» изображения сравнивается с шаблоном так, чтобы сравнение не зависело от яркости и контраста. Используются быстрые суммирования по окну (интегральные суммы), чтобы не считать заново одно и то же для каждой позиции.
- ACF: сравниваем картинку саму с собой при разных сдвигах. Вместо долгого перебора всех сдвигов берём быстрый путь через БПФ: это математический трюк, позволяющий получить все сдвиги сразу. Затем нормируем и выделяем самые сильные сдвиги.

## Где лежат примеры изображений

- Папка `imgs/` содержит несколько примеров, на которых удобно проверять работу: текстуры, повторяющиеся узоры, точки.

Если хотите, могу дополнить файл скриншотами с примером интерпретации карт NCC/ACF для ваших изображений из `imgs/`.
