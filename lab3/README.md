# Описание Алгоритмов Обработки Изображений

Этот документ содержит подробное описание алгоритмов, реализованных в файле `main.py`. Каждый раздел включает теоретическое объяснение алгоритма, его код на Python и подробный разбор каждой строки кода.

---

## 1. Коробочное размытие (Box Blur)

### Описание алгоритма

Коробочное размытие — это простой фильтр размытия, который усредняет значения пикселей в определенном "окне" или "коробке". Для каждого пикселя изображения берется квадратная область (ядро) с центром в этом пикселе. Значение центрального пикселя заменяется на среднее арифметическое всех пикселей внутри этой области.

Этот метод эффективно сглаживает изображение и убирает шум, но может создавать артефакты в виде "квадратов", так как все пиксели в ядре имеют одинаковый вес.

В данной реализации используется оптимизация: вместо дорогостоящей 2D-свертки применяется **сепарабельная (разделяемая) свертка**. Это означает, что 2D-операция разбивается на две 1D-операции:
1.  Сначала изображение размывается по горизонтали с помощью 1D-ядра.
2.  Затем результат размывается по вертикали с помощью того же 1D-ядра.

Это значительно быстрее, особенно для больших ядер размытия.

### Код алгоритма

```python
def box_blur(img: Image.Image, size: int = 3, padding: str = "reflect") -> Image.Image:
    if size % 2 == 0 or size < 1:
        raise ValueError("Kernel size must be positive odd integer")
    arr = _ensure_numpy_array(img)
    k1d = np.ones((size,), dtype=np.float32) / float(size)
    out = _convolve1d(arr, k1d, axis=1, padding=padding)
    out = _convolve1d(out, k1d, axis=0, padding=padding)
    return _to_pil_image(out)
```

### Объяснение кода

| Строка | Код | Объяснение |
| :--- | :--- | :--- |
| 1 | `def box_blur(img: Image.Image, size: int = 3, padding: str = "reflect") -> Image.Image:` | Объявление функции. `img` — входное изображение, `size` — размер ядра (нечетное число), `padding` — метод обработки границ. |
| 2-3 | `if size % 2 == 0 or size < 1: raise ValueError(...)` | Проверка, что размер ядра — положительное нечетное число. Это нужно для симметричного ядра с четким центром. |
| 4 | `arr = _ensure_numpy_array(img)` | Преобразование изображения из формата PIL в массив NumPy для математических операций. |
| 5 | `k1d = np.ones((size,), dtype=np.float32) / float(size)` | Создание 1D-ядра для размытия. Это просто массив из единиц, нормализованный (разделенный на свой размер), чтобы сумма его элементов была равна 1. Это гарантирует, что общая яркость изображения не изменится. |
| 6 | `out = _convolve1d(arr, k1d, axis=1, padding=padding)` | Применение 1D-свертки по горизонтали (`axis=1`). Каждый пиксель заменяется на среднее значение своих горизонтальных соседей. |
| 7 | `out = _convolve1d(out, k1d, axis=0, padding=padding)` | Применение 1D-свертки по вертикали (`axis=0`) к результату предыдущего шага. |
| 8 | `return _to_pil_image(out)` | Преобразование обработанного массива NumPy обратно в изображение PIL и его возврат. |

---

## 2. Размытие по Гауссу (Gaussian Blur)

### Описание алгоритма

Размытие по Гауссу — это более продвинутый фильтр размытия, который также усредняет пиксели, но с разными весами. Пиксели, находящиеся ближе к центру ядра, имеют больший вес, а пиксели на краях — меньший. Веса распределяются в соответствии с функцией Гаусса (форма "колокола").

Это позволяет достичь более плавного и естественного размытия по сравнению с коробочным размытием, избегая артефактов. Параметр `sigma` контролирует ширину "колокола": чем больше `sigma`, тем сильнее размытие.

Как и Box Blur, этот фильтр реализован с использованием **сепарабельной свертки** для высокой производительности.

### Код алгоритма

```python
def gaussian_blur(img: Image.Image, size: int = 5, sigma: float = 1.0, padding: str = "reflect") -> Image.Image:
    arr = _ensure_numpy_array(img)
    k1d = _gaussian_kernel1d(size, sigma)
    out = _convolve1d(arr, k1d, axis=1, padding=padding)
    out = _convolve1d(out, k1d, axis=0, padding=padding)
    return _to_pil_image(out)
```

### Объяснение кода

| Строка | Код | Объяснение |
| :--- | :--- | :--- |
| 1 | `def gaussian_blur(img: Image.Image, size: int = 5, sigma: float = 1.0, padding: str = "reflect") -> Image.Image:` | Объявление функции. `size` — размер ядра, `sigma` — стандартное отклонение функции Гаусса. |
| 2 | `arr = _ensure_numpy_array(img)` | Преобразование изображения в массив NumPy. |
| 3 | `k1d = _gaussian_kernel1d(size, sigma)` | Создание 1D-ядра Гаусса. Веса в ядре рассчитываются по формуле Гаусса и нормализуются. |
| 4 | `out = _convolve1d(arr, k1d, axis=1, padding=padding)` | Применение 1D-свертки по Гауссу по горизонтали (`axis=1`). |
| 5 | `out = _convolve1d(out, k1d, axis=0, padding=padding)` | Применение 1D-свертки по Гауссу по вертикали (`axis=0`). |
| 6 | `return _to_pil_image(out)` | Преобразование результата обратно в изображение PIL. |

---

## 3. Медианный фильтр (Median Filter)

### Описание алгоритма

Медианный фильтр — это нелинейный фильтр, который отлично подходит для удаления "импульсного" шума (также известного как "соль и перец"). В отличие от фильтров размытия, он не усредняет значения пикселей.

Для каждого пикселя изображения:
1.  Берется область (окно) с центром в этом пикселе.
2.  Все значения пикселей из этой области собираются в список.
3.  Список сортируется.
4.  Значение центрального пикселя заменяется на **медиану** — средний элемент отсортированного списка.

Главное преимущество медианного фильтра в том, что он хорошо сохраняет резкие границы на изображении, в отличие от размывающих фильтров.

### Код алгоритма

```python
def median_filter(img: Image.Image, size: int = 3, padding: str = "reflect") -> Image.Image:
    if size % 2 == 0 or size < 1:
        raise ValueError("Window size must be positive odd integer")
    from numpy.lib.stride_tricks import sliding_window_view
    arr = _ensure_numpy_array(img)
    kh, kw = size, size
    ph, pw = kh // 2, kw // 2
    arr_p = _pad_image(arr, ph, pw, mode=padding)
    c_first = np.transpose(arr_p, (2, 0, 1))
    windows = sliding_window_view(c_first, (1, kh, kw))
    windows = windows[:, :, :, 0, :, :]
    out_c = np.median(windows, axis=(-2, -1))
    out = np.transpose(out_c, (1, 2, 0)).astype(np.float32)
    return _to_pil_image(out)
```

### Объяснение кода

| Строка | Код | Объяснение |
| :--- | :--- | :--- |
| 1-3 | `def median_filter(...)` / `if size % 2 == 0 ...` | Объявление функции и проверка корректности размера окна. |
| 4 | `from numpy.lib.stride_tricks import sliding_window_view` | Импорт утилиты NumPy для создания "скользящих окон", что позволяет векторизовать операцию. |
| 5 | `arr = _ensure_numpy_array(img)` | Преобразование изображения в массив NumPy. |
| 6-8 | `kh, kw = size, size` ... `arr_p = _pad_image(...)` | Определение размеров окна и добавление отступов (padding) к изображению, чтобы обработать пиксели на границах. |
| 9 | `c_first = np.transpose(arr_p, (2, 0, 1))` | Перестановка осей массива из `(H, W, C)` в `(C, H, W)` (каналы вначале) для удобства обработки. |
| 10 | `windows = sliding_window_view(c_first, (1, kh, kw))` | Создание "виртуального" 6D-массива, где для каждого пикселя доступно его 2D-соседство (окно). Это делается без копирования данных, что очень эффективно. |
| 11 | `windows = windows[:, :, :, 0, :, :]` | Упрощение формы массива до `(C, H, W, kh, kw)`. |
| 12 | `out_c = np.median(windows, axis=(-2, -1))` | **Ключевой шаг**: вычисление медианы по последним двум осям (`kh`, `kw`), то есть внутри каждого окна. Результат — массив `(C, H, W)`. |
| 13 | `out = np.transpose(out_c, (1, 2, 0))...` | Возвращение осей в исходный порядок `(H, W, C)`. |
| 14 | `return _to_pil_image(out)` | Преобразование результата в изображение PIL. |

---

## 4. Оператор Собеля (Sobel Operator)

### Описание алгоритма

Оператор Собеля — это алгоритм для **обнаружения границ** на изображении. Он выделяет области с высоким градиентом яркости, то есть резкие переходы от светлого к темному и наоборот.

Алгоритм работает следующим образом:
1.  Изображение преобразуется в оттенки серого.
2.  Применяются две свертки с двумя разными ядрами Собеля:
    *   `Kx` — для обнаружения горизонтальных градиентов (вертикальных линий).
    *   `Ky` — для обнаружения вертикальных градиентов (горизонтальных линий).
3.  Результаты сверток (`Gx` и `Gy`) представляют собой "силу" градиента в каждом направлении для каждого пикселя.
4.  Итоговая величина градиента (сила границы) вычисляется по формуле: `G = sqrt(Gx² + Gy²)`.
5.  Полученное изображение нормализуется, чтобы значения яркости находились в диапазоне от 0 до 255.

### Код алгоритма

```python
def sobel_operator(img: Image.Image, padding: str = "reflect", to_grayscale: bool = True) -> Image.Image:
    arr = _ensure_numpy_array(img)
    # Convert to grayscale for edge magnitude
    if arr.shape[2] == 3:
        gray = 0.299 * arr[:, :, 0] + 0.587 * arr[:, :, 1] + 0.114 * arr[:, :, 2]
    else:
        gray = arr[:, :, 0]
    gray3 = gray[:, :, None].astype(np.float32)
    kx = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=np.float32)
    ky = np.array([[-1, -2, -1], [0,  0,  0], [1,  2,  1]], dtype=np.float32)
    gx = _convolve(gray3, kx, padding=padding)[:, :, 0]
    gy = _convolve(gray3, ky, padding=padding)[:, :, 0]
    mag = np.sqrt(gx * gx + gy * gy)
    # Normalize to 0..255
    mmin, mmax = float(mag.min()), float(mag.max())
    if mmax > mmin:
        mag = (mag - mmin) * (255.0 / (mmax - mmin))
    else:
        mag = np.zeros_like(mag)
    if to_grayscale:
        return _to_pil_image(mag.astype(np.float32))
    else:
        # If preserving RGB, apply same magnitude to all channels
        rgb = np.repeat(mag[:, :, None], 3, axis=2)
        return _to_pil_image(rgb.astype(np.float32))
```

### Объяснение кода

| Строка | Код | Объяснение |
| :--- | :--- | :--- |
| 1 | `def sobel_operator(...)` | Объявление функции. `to_grayscale` определяет, будет ли результат черно-белым или цветным. |
| 2 | `arr = _ensure_numpy_array(img)` | Преобразование изображения в массив NumPy. |
| 4-7 | `if arr.shape[2] == 3: ... else: ...` | Преобразование цветного изображения в оттенки серого по стандартной формуле. Если изображение уже серое, оно используется как есть. |
| 8 | `gray3 = gray[:, :, None].astype(np.float32)` | Добавление "канальной" оси к серому изображению, чтобы его форма была `(H, W, 1)`, совместимой с функцией свертки. |
| 9-12 | `kx = np.array(...)` / `ky = np.array(...)` | Определение ядер Собеля для горизонтального (`kx`) и вертикального (`ky`) градиентов. |
| 13 | `gx = _convolve(gray3, kx, ...)` | Применение свертки с ядром `kx` для получения горизонтального градиента `gx`. |
| 14 | `gy = _convolve(gray3, ky, ...)` | Применение свертки с ядром `ky` для получения вертикального градиента `gy`. |
| 15 | `mag = np.sqrt(gx * gx + gy * gy)` | Вычисление итоговой величины градиента для каждого пикселя. |
| 17-20 | `mmin, mmax = ...` / `if mmax > mmin: ...` | Нормализация изображения: растягивание диапазона яркостей до `[0, 255]` для корректного отображения. |
| 21-26 | `if to_grayscale: ... else: ...` | Возврат результата. Либо как черно-белое изображение границ, либо (если `to_grayscale=False`) величина градиента копируется во все три RGB-канала, создавая цветное изображение границ. |

---

## 5. Глубокое погружение: Сепарабельная (разделяемая) свертка

Это ключевая оптимизация, используемая в `box_blur` и `gaussian_blur`. Давайте разберемся в ней подробнее.

### 1. Изменяется ли результат по сравнению с 2D-сверткой?

**Нет, результат математически идентичен.**

Это возможно только потому, что ядра фильтров Box Blur и Gaussian Blur являются **сепарабельными**. Это означает, что их 2D-матрицу можно представить как произведение двух 1D-векторов: одного вертикального и одного горизонтального.

Например, 2D-ядро Box Blur 3x3 (без нормализации) выглядит так:

```
[[1, 1, 1],
 [1, 1, 1],
 [1, 1, 1]]
```

Его можно получить, умножив вертикальный вектор `[1, 1, 1]` на горизонтальный `[1, 1, 1]`:

```
[1]   *   [1, 1, 1]   =   [[1, 1, 1],
[1]                       [1, 1, 1],
[1]                       [1, 1, 1]]
```

Поскольку операция свертки ассоциативна, применение 2D-ядра за один проход дает тот же результат, что и последовательное применение двух 1D-ядер.

**Важно:** Не все фильтры сепарабельны. Например, оператор Собеля, который вы также используете, не является сепарабельным, поэтому его приходится вычислять с помощью полноценной 2D-свертки (`_convolve`).

### 2. Насколько это быстрее и почему?

**Значительно быстрее.** Выигрыш в производительности растет линейно с увеличением размера ядра.

Причина кроется в количестве вычислений (умножений) на каждый пиксель изображения.
- **Стандартная 2D-свертка:** Для ядра размером `K x K` требуется `K * K` (или `K²`) умножений на пиксель.
- **Сепарабельная 1D-свертка:** Выполняется в два прохода:
    1.  Горизонтальный проход: `K` умножений на пиксель.
    2.  Вертикальный проход: `K` умножений на пиксель.
    - **Итого:** `K + K = 2K` умножений на пиксель.

**Сравнение сложности:** `O(K²)` против `O(2K)`.

| Размер ядра (K) | 2D-свертка (K²) | Сепарабельная (2K) | Ускорение (K²/2K) |
| :--- | :--- | :--- | :--- |
| 3x3 | 9 | 6 | **1.5x** |
| 5x5 | 25 | 10 | **2.5x** |
| 9x9 | 81 | 18 | **4.5x** |
| 25x25 | 625 | 50 | **12.5x** |

Как видите, для больших радиусов размытия оптимизация становится критически важной.

### 3. Как это работает: наглядный пример

Представим, что мы применяем Box Blur 3x3 к одному пикселю `P5` и его соседям.

**Исходные пиксели:**
```
P1 P2 P3
P4 P5 P6
P7 P8 P9
```

#### Шаг 1: Горизонтальный проход (применяем 1D-ядро `[1, 1, 1] / 3`)

Мы вычисляем промежуточные значения для центральной строки. Значение каждого нового пикселя — это среднее его самого и его горизонтальных соседей в **оригинальном** изображении.

- `P4' = (P1 + P2 + P3) / 3`
- `P5' = (P4 + P5 + P6) / 3`
- `P6' = (P7 + P8 + P9) / 3`

Получаем **промежуточное изображение** (показана только центральная строка, но так делается для всех строк):

```
... ... ...
P4' P5' P6'
... ... ...
```

#### Шаг 2: Вертикальный проход (применяем 1D-ядро `[1, 1, 1] / 3`)

Теперь мы работаем с **промежуточным изображением**. Чтобы получить финальное значение для центрального пикселя, мы берем его промежуточное значение `P5'` и усредняем с его вертикальными соседями (которые также являются промежуточными значениями).

- `P5_final = (P2' + P5' + P8') / 3`

Если мы подставим значения из Шага 1, то получим:

`P5_final = ( ((P1+P2+P3)/3) + ((P4+P5+P6)/3) + ((P7+P8+P9)/3) ) / 3`
`P5_final = (P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9) / 9`

Этот результат **в точности совпадает** с тем, что мы бы получили, применив 2D-ядро 3x3 за один раз.

---

## 6. Вспомогательные функции (Helper Functions)

Эти функции являются строительными блоками для основных алгоритмов.

### `_ensure_numpy_array`
**Назначение:** Гарантированно преобразует изображение из формата `PIL.Image` в массив `numpy.ndarray` для выполнения математических операций.

**Код:**
```python
def _ensure_numpy_array(img: Image.Image) -> "np.ndarray":
    if np is None:
        raise SystemExit("NumPy is required. Install with: pip install numpy")
    if img.mode not in ("RGB", "L"):
        img = img.convert("RGB")
    arr = np.array(img, dtype=np.float32)
    if arr.ndim == 2:
        arr = arr[:, :, None]
    return arr
```

**Объяснение:**
- **Проверка NumPy:** Убеждается, что библиотека NumPy установлена.
- **Конвертация цвета:** Если изображение имеет сложный режим (например, `P` с палитрой), оно конвертируется в стандартный `RGB`.
- **Преобразование в массив:** Создает массив NumPy с типом данных `float32` для точности вычислений.
- **Добавление оси канала:** Если изображение черно-белое (2 измерения: высота и ширина), добавляется третья ось для канала. Это унифицирует формат массива до `(высота, ширина, каналы)`, что упрощает дальнейшую обработку.

### `_to_pil_image`
**Назначение:** Преобразует обработанный массив `numpy.ndarray` обратно в изображение `PIL.Image` для отображения или сохранения.

**Код:**
```python
def _to_pil_image(arr: "np.ndarray") -> Image.Image:
    arr_clipped = np.clip(arr, 0, 255).astype(np.uint8)
    if arr_clipped.ndim == 2:
        return Image.fromarray(arr_clipped)
    if arr_clipped.shape[2] == 1:
        arr_clipped = arr_clipped[:, :, 0]
        return Image.fromarray(arr_clipped)
    return Image.fromarray(arr_clipped)
```

**Объяснение:**
- **Ограничение значений (`clip`):** Гарантирует, что все значения пикселей находятся в допустимом диапазоне `[0, 255]`.
- **Изменение типа:** Преобразует массив к типу `uint8` (целые числа от 0 до 255), который является стандартным для изображений.
- **Создание изображения:** Использует `Image.fromarray()` для создания объекта изображения PIL из массива. Обрабатывает как цветные (3 канала), так и черно-белые (1 канал) массивы.

### `_pad_image`
**Назначение:** Добавляет "отступы" (padding) по краям изображения. Это необходимо, чтобы фильтры (например, свертка) могли корректно обработать пиксели на границах изображения, так как ядру фильтра нужно выходить за пределы исходных границ.

**Код:**
```python
def _pad_image(arr: "np.ndarray", pad_y: int, pad_x: int, mode: str = "reflect") -> "np.ndarray":
    if mode not in ("reflect", "edge", "constant"):
        mode = "reflect"
    if mode == "constant":
        return np.pad(arr, ((pad_y, pad_y), (pad_x, pad_x), (0, 0)), mode="constant")
    if mode == "edge":
        return np.pad(arr, ((pad_y, pad_y), (pad_x, pad_x), (0, 0)), mode="edge")
    return np.pad(arr, ((pad_y, pad_y), (pad_x, pad_x), (0, 0)), mode="reflect")
```

**Объяснение:**
- **`mode`:** Определяет, как заполнять отступы:
    - `reflect` (по умолчанию): Зеркально отражает пиксели от границы. Дает наилучшие визуальные результаты.
    - `edge`: Копирует значения крайних пикселей.
    - `constant`: Заполняет нулями (черным цветом).
- **`np.pad`:** Функция NumPy, которая эффективно добавляет отступы к массиву. Отступы добавляются по вертикали (`pad_y`) и горизонтали (`pad_x`), но не для каналов `(0, 0)`.

### `_convolve` и `_convolve1d`
**Назначение:** Выполняют операцию **свертки**, которая является основой для большинства линейных фильтров (Box Blur, Gaussian Blur, Sobel). `_convolve` выполняет 2D-свертку, а `_convolve1d` — 1D-свертку для сепарабельных (разделяемых) фильтров.

**Объяснение:**
Свертка — это процесс "скольжения" небольшого ядра (матрицы) по изображению. На каждом шаге вычисляется взвешенная сумма пикселей, накрытых ядром, и результат записывается в центральный пиксель.

Эти функции используют продвинутые техники NumPy (`sliding_window_view`, `einsum`) для выполнения свертки очень быстро, без написания медленных циклов на Python.
- `sliding_window_view`: Создает "окна" нужного размера для каждого пикселя без копирования данных.
- `einsum` (Einstein summation): Выполняет умножение окон на ядро и их суммирование в одной оптимизированной операции.

### `_gaussian_kernel1d`
**Назначение:** Создает одномерное (1D) ядро для Гауссова размытия.

**Код:**
```python
def _gaussian_kernel1d(size: int, sigma: float) -> "np.ndarray":
    if size % 2 == 0 or size < 1:
        raise ValueError("Kernel size must be positive odd integer")
    if sigma <= 0:
        raise ValueError("Sigma must be positive")
    ax = np.arange(-(size // 2), size // 2 + 1, dtype=np.float32)
    k = np.exp(-(ax**2) / (2.0 * sigma * sigma))
    k /= np.sum(k)
    return k.astype(np.float32)
```

**Объяснение:**
- **Создание оси (`ax`):** Генерирует ряд чисел с центром в нуле (например, `[-2, -1, 0, 1, 2]` для `size=5`).
- **Формула Гаусса:** Применяет 1D-функцию Гаусса `exp(-x² / (2σ²))` к каждой точке на оси.
- **Нормализация:** Делит все элементы ядра на их сумму. Это гарантирует, что общая яркость изображения не изменится после применения фильтра.


